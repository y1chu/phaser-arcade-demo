<!DOCTYPE html>
<html>
<head>
    <title>接星星 Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2d2d2d;
        }
        canvas {
            border: 2px solid #fff;
        }
    </style>
</head>
<body>

<script>

class CoinCatcherScene extends Phaser.Scene {
    constructor() {
        super('CoinCatcherScene');
        this.player = null;
        this.stars = null;
        this.bombs = null;
        this.cursors = null;
        this.score = 0;
        this.scoreText = null;
        this.gameOver = false;
        this.timerValue = 60;
        this.timerText = null;
        this.starSpawner = null;
        this.bombSpawner = null;
        this.fpsText = null;
        this.objectCountText = null;
        this.entityCount = 0;
    }

    preload() {
        this.load.image('sky', 'https://labs.phaser.io/assets/skies/space3.png');
        this.load.image('star', 'https://labs.phaser.io/assets/sprites/star.png');
        this.load.image('bomb', 'assets/bomb.png'); 
        this.load.spritesheet('dude', 'https://labs.phaser.io/assets/sprites/dude.png', { frameWidth: 32, frameHeight: 48 });
    }

    create() {
        this.score = 0;
        this.timerValue = 60;
        this.gameOver = false;

        this.add.image(400, 300, 'sky');
        
        // 功能: 建立一個受物理引擎控制的玩家角色 (Sprite)
        // 原理: `this.physics.add.sprite` 會建立一個同時具有「圖片」和「物理身體(body)」的物件
        // 為何: 只有受物理引擎控制的物件，才能進行速度設定、碰撞檢測等物理相關操作
        this.player = this.physics.add.sprite(400, 500, 'dude');
    
        // 功能: 設定玩家與世界邊界的碰撞
        // 原理: 將此設為 true 後，物理引擎會阻止此物件的物理身體離開 `this.physics.world.bounds` 所設定的範圍
        // 為何: 確保玩家角色不會移動到遊戲畫面之外
        this.player.setCollideWorldBounds(true);
        
        // 功能: 設定此物件是否受重力影響
        // 原理: Arcade Physics 預設會對所有動態物件施加一個全域重力。設為 false 可以豁免此物件
        // 為何: 希望玩家只在水平方向上移動，不受垂直重力的影響而下墜
        this.player.body.allowGravity = false;

        this.anims.create({ key: 'left', frames: this.anims.generateFrameNumbers('dude', { start: 0, end: 3 }), frameRate: 10, repeat: -1 });
        this.anims.create({ key: 'turn', frames: [ { key: 'dude', frame: 4 } ], frameRate: 20 });
        this.anims.create({ key: 'right', frames: this.anims.generateFrameNumbers('dude', { start: 5, end: 8 }), frameRate: 10, repeat: -1 });

        // 功能: 建立物理群組來管理星星和炸彈
        // 原理: `group` 是一個可以存放大量同類型物理物件的容器。對群組進行操作 (如設定碰撞)，效果等同於對群組內的每個物件進行操作
        // 為何: 遊戲中會不斷產生和銷毀大量的星星與炸彈，使用群組進行管理效能更高、程式碼也更簡潔
        this.stars = this.physics.add.group();
        this.bombs = this.physics.add.group();

        
        // 功能: 設定玩家與星星/炸彈之間的「重疊」偵測
        // 原理: `overlap` 會持續檢查玩家的物理身體是否與 `stars` 或 `bombs` 群組中的任何一個物件的物理身體發生重疊
        // 為何: 我們只需要「知道」玩家碰到了星星或炸彈，並觸發對應的函式 (得分/扣分)，而不需要產生任何實際的物理碰撞效果 (如反彈)。因此 `overlap` 是最適合的選擇
        this.physics.add.overlap(this.player, this.stars, this.collectStar, null, this);
        this.physics.add.overlap(this.player, this.bombs, this.hitBomb, null, this);

        this.scoreText = this.add.text(16, 16, '分數: 0', { fontSize: '32px', fill: '#fff' });
        this.timerText = this.add.text(config.width - 16, 16, '時間: ' + this.timerValue, { fontSize: '32px', fill: '#fff' }).setOrigin(1, 0);
        this.fpsText = this.add.text(16, 50, 'FPS: 60', { fontSize: '20px', fill: '#fff' });
        this.objectCountText = this.add.text(16, 75, '物件數: 0', { fontSize: '20px', fill: '#fff' });

        this.cursors = this.input.keyboard.createCursorKeys();

        this.starSpawner = this.time.addEvent({ delay: 800, callback: this.spawnStar, callbackScope: this, loop: true });
        this.bombSpawner = this.time.addEvent({ delay: 2000, callback: this.spawnBomb, callbackScope: this, loop: true });
        
        this.time.addEvent({ delay: 1000, callback: this.updateTimer, callbackScope: this, loop: true });

        this.updateEntityCount();
    }

    update() {
        this.fpsText.setText('FPS: ' + Math.floor(this.game.loop.actualFps));

        if (this.gameOver) {
            return;
        }

        // 功能: 設定玩家的水平速度
        // 原理: `setVelocityX` 是 Arcade Physics 提供的函式，用於直接設定一個物理身體在 X 軸上的速度。正值向右，負值向左
        // 為何: 這是控制物理角色移動最直接、最常見的方式。物理引擎會根據這個速度值，在每一幀自動更新角色的位置
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-350);
            this.player.anims.play('left', true);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(350);
            this.player.anims.play('right', true);
        } else {
            this.player.setVelocityX(0);
            this.player.anims.play('turn');
        }

        this.cleanupOffscreenObjects(this.stars);
        this.cleanupOffscreenObjects(this.bombs);
    }

    cleanupOffscreenObjects(group) {
        group.children.each(child => {
            if (child && child.y > config.height + 50) {
                child.destroy();
                this.updateEntityCount();
            }
        });
    }
    
    updateEntityCount() {
        let count = 1; 
        if (this.stars) count += this.stars.countActive(true);
        if (this.bombs) count += this.bombs.countActive(true);
        this.objectCountText.setText('物件數: ' + count);
    }

    updateTimer() {
        if (this.gameOver) return;
        this.timerValue--;
        this.timerText.setText('時間: ' + this.timerValue);
        if (this.timerValue <= 0) {
            this.endGame();
        }
    }

    spawnStar() {
        const x = Phaser.Math.Between(50, 750);
        const star = this.stars.create(x, -50, 'star');
        star.setScale(0.5);
        
        // 功能: 設定星星的垂直速度
        // 原理: `setVelocityY` 用於設定物理身體在 Y 軸上的速度。正值向下
        // 為何: 不使用全域重力，而是手動給予每個星星一個隨機的下落速度，這樣可以讓遊戲畫面看起來更豐富多變
        star.setVelocityY(Phaser.Math.Between(100, 200));
        this.updateEntityCount();
    }

    spawnBomb() {
        const x = Phaser.Math.Between(50, 750);
        const bomb = this.bombs.create(x, -50, 'bomb');
        bomb.setScale(0.2);
        bomb.setVelocityY(Phaser.Math.Between(150, 250));
        this.updateEntityCount();
    }

    collectStar(player, star) {
        star.destroy();
        this.score += 10;
        this.scoreText.setText('分數: ' + this.score);
        this.updateEntityCount();
    }

    hitBomb(player, bomb) {
        bomb.destroy();
        this.score -= 20;
        this.scoreText.setText('分數: ' + this.score);
        this.updateEntityCount();

        this.cameras.main.shake(100, 0.01);
        player.setTint(0xff0000);
        this.time.delayedCall(100, () => {
            player.clearTint();
        });
    }

    endGame() {
        this.gameOver = true;
        
        // 功能: 暫停整個場景的物理引擎
        // 原理: `this.physics.pause()` 會凍結所有物理計算，物件將停止移動、不再觸發碰撞或重疊事件
        // 為何: 當遊戲結束時，希望所有物件都停在原位，等待重新開始
        this.physics.pause();
        this.player.anims.play('turn');

        this.starSpawner.remove();
        this.bombSpawner.remove();
        
        const gameOverText = `時間到！\n\n你的分數: ${this.score}\n\n點擊畫面重新開始`;
        this.add.text(400, 300, gameOverText, { 
            fontSize: '48px', 
            fill: '#fff', 
            align: 'center',
            backgroundColor: 'rgba(0,0,0,0.5)',
            padding: { x: 20, y: 20 }
        }).setOrigin(0.5);

        this.input.once('pointerdown', () => {
            this.scene.restart();
        });
    }
}

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    
    // 功能: 在遊戲設定中啟用 Arcade 物理引擎
    // 原理: `default: 'arcade'` 將 Arcade Physics 設為預設引擎
    // 為何: 這是所有物理效果的基礎。注意，在此版本中移除了全域重力，為每個掉落物手動設定了速度
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: CoinCatcherScene
};

const game = new Phaser.Game(config);

</script>

</body>
</html>
