<!DOCTYPE html>
<html>
<head>
    <title>射擊遊戲Demo</title>
    <meta charset="utf-8" />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas { border: 1px solid #fff; }
    </style>
</head>
<body>

<script>
class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'enemy');

        // 功能: 確保這個自訂物件被正式加入到場景的顯示列表和物理世界中
        // 原理: `scene.add.existing` 讓物件可見，`scene.physics.add.existing` 賦予它物理身體
        // 為何: 這是自訂物理 Sprite 類別的標準初始化流程，確保它能被正確渲染和進行物理運算
        scene.add.existing(this);
        scene.physics.add.existing(this);

        this.hp = 0;
        this.maxHp = 0;
        this.hpBar = scene.add.graphics();
    }

    spawn(x, y) {
        this.setPosition(x, y);
        this.setActive(true).setVisible(true);

        // 功能: 啟用這個物件的物理身體
        // 原理: 當物件被回收再利用時，它的物理身體可能已被禁用。`body.enable = true` 會重新激活它，讓它可以再次移動和碰撞
        // 為何: 這是物件池模式中的關鍵一步，確保回收的敵機能夠正常運作
        this.body.enable = true;
        this.maxHp = Phaser.Math.Between(1, 10);
        this.hp = this.maxHp;
        this.setVelocityY(100);
        this.setScale(0.1);

        if (!this.hpBar || this.hpBar.destroyed) {
            this.hpBar = this.scene.add.graphics();
        }
        this.updateHpBar();
    }

    updateHpBar() {
        if (!this.active || !this.hpBar || this.hpBar.destroyed) return;
        this.hpBar.clear();
        const percent = Phaser.Math.Clamp(this.hp / this.maxHp, 0, 1);
        const barX = this.x - 20;
        const barY = this.y - 30;
        const barWidth = 40;
        const barHeight = 5;
        this.hpBar.fillStyle(0xff0000);
        this.hpBar.fillRect(barX, barY, barWidth, barHeight);
        this.hpBar.fillStyle(0x00ff00);
        this.hpBar.fillRect(barX, barY, barWidth * percent, barHeight);
    }

    takeDamage(dmg) {
        this.hp -= dmg;
        this.updateHpBar();

        if (this.hp <= 0) {
            this.scene.score += this.maxHp * 10;
            this.scene.scoreText.setText('分數: ' + this.scene.score);
            const explosion = this.scene.add
                .sprite(this.x, this.y, 'explosion')
                .play('explode');
            explosion.on('animationcomplete', () => explosion.destroy());

            // 功能: 停用這個物件的物理身體
            // 原理: `body.enable = false` 會讓物理引擎在下一次運算時忽略這個物件，它將不再移動或觸發任何碰撞
            // 為何: 在物件死亡但尚未銷毀的過渡階段 (例如播放死亡動畫時)，禁用物理身體可以防止它繼續與其他物體互動
            this.body.enable = false;
            this.setActive(false).setVisible(false);
            this.hpBar.clear();
        }
    }

    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) {
            this.updateHpBar();
            if (this.y > this.scene.game.config.height + 50) {
                this.setActive(false).setVisible(false);
                this.destroy();
            }
        }
    }
    
    preDestroy() {
        if (this.hpBar) {
            this.hpBar.destroy();
            this.hpBar = null;
        }
    }
}

class ShooterScene extends Phaser.Scene {
    constructor() {
        super('ShooterScene');
        this.player = null;
        this.enemies = null;
        this.bullets = null;
        this.starfield = null;
        this.keys = null;
        this.score = 0;
        this.scoreText = null;
        this.gameOver = false;
        this.fireRate = 200;
        this.nextFire = 0;
        this.fpsText = null;
        this.objectCountText = null;
        this.enemySpawner = null;
    }

    preload() {
        this.load.image('starfield', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/skies/starfield.png');
        this.load.image('player', 'assets/spaceship.png');
        this.load.image('enemy', 'assets/alien.png');
        this.load.image('bullet', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/bullet.png');
        this.load.spritesheet('explosion', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/explosion.png', { frameWidth: 64, frameHeight: 64 });
    }

    create() {
        this.score = 0;
        this.gameOver = false;
        this.nextFire = 0;

        this.starfield = this.add.tileSprite(400, 300, 800, 600, 'starfield');

        this.player = this.physics.add.sprite(400, 500, 'player');
        this.player.setCollideWorldBounds(true);
        this.player.body.allowGravity = false;
        this.player.setScale(0.3);

        this.anims.create({
            key: 'explode',
            frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: 15 }),
            frameRate: 24,
            repeat: 0,
            hideOnComplete: true
        });
        
        // 功能: 建立物理群組來管理敵人，並指定使用自訂的 Enemy 類別
        // 原理: `group` 是一個可以存放大量同類型物理物件的容器。`classType: Enemy` 告訴群組在需要新物件時，應該要建立自訂的 Enemy 實體
        // 為何: 這樣可以讓在 Enemy 類別中集中管理血量、血條等複雜邏輯，讓主場景的程式碼更簡潔
        this.enemies = this.physics.add.group({
            classType: Enemy,
            runChildUpdate: true
        });

        this.bullets = this.physics.add.group({
            removeCallback: (bullet) => {
                this.updateEntityCount();
            }
        });
        
        // 功能: 設定子彈與敵人、玩家與敵人之間的「重疊」偵測
        // 原理: `overlap` 會持續檢查兩個群組/物件的物理身體是否發生重疊。一旦重疊，就會觸發指定的回呼函式 (如 bulletHitEnemy)
        // 為何: 只需要「知道」它們碰到了，並觸發對應的邏輯 (扣血/遊戲結束)，不需要產生任何物理反彈效果，所以 `overlap` 是最適合且效能最好的選擇
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.playerHitEnemy, null, this);

        this.scoreText = this.add.text(16, 16, '分數: 0', { fontSize: '32px', fill: '#fff' });
        this.fpsText = this.add.text(16, 50, 'FPS: 60', { fontSize: '20px', fill: '#fff' });
        this.objectCountText = this.add.text(16, 75, '物件數: 0', { fontSize: '20px', fill: '#fff' });

        this.keys = this.input.keyboard.addKeys('W,S,A,D,LEFT,RIGHT,UP,DOWN,SPACE');

        this.enemySpawner = this.time.addEvent({
            delay: 1200,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true
        });
        
        this.updateEntityCount();
    }

    update(time, delta) {
        this.fpsText.setText('FPS: ' + Math.floor(this.game.loop.actualFps));

        if (this.gameOver) return;

        this.starfield.tilePositionY -= 2;

        // 功能: 設定玩家的速度
        // 原理: `setVelocity` 是 Arcade Physics 提供的函式，用於直接設定一個物理身體的速度向量
        // 為何: 這是控制物理角色移動最直接的方式。先將速度歸零，然後根據按鍵輸入設定新的速度。物理引擎會根據這些速度值自動更新飛船的位置
        this.player.setVelocity(0);
        if (this.keys.A.isDown || this.keys.LEFT.isDown) {
            this.player.setVelocityX(-300);
        } else if (this.keys.D.isDown || this.keys.RIGHT.isDown) {
            this.player.setVelocityX(300);
        }

        if (this.keys.W.isDown || this.keys.UP.isDown) {
            this.player.setVelocityY(-300);
        } else if (this.keys.S.isDown || this.keys.DOWN.isDown) {
            this.player.setVelocityY(300);
        }

        if (this.keys.SPACE.isDown && time > this.nextFire) {
            this.shootBullet(time);
        }
    }

    updateEntityCount() {
        const count = 1 + this.bullets.countActive(true) + this.enemies.countActive(true);
        this.objectCountText.setText('物件數: ' + count);
    }

    spawnEnemy() {
        const x = Phaser.Math.Between(50, 750);
        const enemy = this.enemies.get();
        if (enemy) {
            enemy.spawn(x, -50);
            this.updateEntityCount();
        }
    }

    shootBullet(time) {
        const bullet = this.bullets.create(this.player.x, this.player.y - 30, 'bullet');
        if (bullet) {
            bullet.setVelocityY(-500);
            bullet.body.allowGravity = false;
            this.nextFire = time + this.fireRate;
            this.updateEntityCount();

            this.time.delayedCall(2000, () => {
                if (bullet.active) {
                    bullet.destroy();
                }
            });
        }
    }

    bulletHitEnemy(bullet, enemy) {
        if (bullet && bullet.active && enemy && enemy.active) {
            bullet.destroy();
            enemy.takeDamage(1);
            this.updateEntityCount();
        }
    }

    playerHitEnemy(player, enemy) {
        if (this.gameOver) return;

        if(this.enemySpawner) this.enemySpawner.destroy();
        
        this.gameOver = true;
        
        // 功能: 暫停整個場景的物理引擎
        // 原理: `this.physics.pause()` 會凍結所有物理計算，物件將停止移動、不再觸發碰撞或重疊事件
        // 為何: 當遊戲結束時，希望所有物件都停在原位，等待重新開始
        this.physics.pause();

        this.add.sprite(player.x, player.y, 'explosion').play('explode');
        this.add.sprite(enemy.x, enemy.y, 'explosion').play('explode');

        player.setVisible(false);
        enemy.destroy();

        this.add.text(400, 300, '遊戲結束\n點擊畫面重新開始', {
            fontSize: '48px',
            fill: '#ff0000',
            align: 'center',
            backgroundColor: 'rgba(0,0,0,0.7)',
            padding: { x: 20, y: 20 }
        }).setOrigin(0.5);

        this.input.once('pointerdown', () => {
            this.scene.restart();
        });
    }
}

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    
    // 功能: 在遊戲設定中啟用 Arcade 物理引擎
    // 原理: `default: 'arcade'` 將 Arcade Physics 設為預設引擎
    // 為何: 這是所有物理效果的基礎。注意，在此遊戲中沒有設定全域重力，因為太空中的物件不應受其影響
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: ShooterScene
};

const game = new Phaser.Game(config);
</script>

</body>
</html>