<!DOCTYPE html>
<html>
<head>
    <title>射擊遊戲Demo</title>
    <meta charset="utf-8" />
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas { border: 1px solid #fff; }
    </style>
</head>
<body>

<script>
class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'enemy');
        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.hp = 0;
        this.maxHp = 0;
        this.hpBar = scene.add.graphics();
    }

    spawn(x, y) {
        this.setPosition(x, y);
        this.setActive(true).setVisible(true);
        this.body.enable = true;
        this.maxHp = Phaser.Math.Between(1, 10);
        this.hp = this.maxHp;
        this.setVelocityY(100);
        this.setScale(0.1);

        if (!this.hpBar || this.hpBar.destroyed) {
            this.hpBar = this.scene.add.graphics();
        }
        this.updateHpBar();
    }

    updateHpBar() {
        if (!this.active || !this.hpBar || this.hpBar.destroyed) return;
        this.hpBar.clear();
        const percent = Phaser.Math.Clamp(this.hp / this.maxHp, 0, 1);
        const barX = this.x - 20;
        const barY = this.y - 30;
        const barWidth = 40;
        const barHeight = 5;

        this.hpBar.fillStyle(0xff0000);
        this.hpBar.fillRect(barX, barY, barWidth, barHeight);
        this.hpBar.fillStyle(0x00ff00);
        this.hpBar.fillRect(barX, barY, barWidth * percent, barHeight);
    }

    takeDamage(dmg) {
        this.hp -= dmg;
        this.updateHpBar();

        if (this.hp <= 0) {
            this.scene.score += this.maxHp * 10;
            this.scene.scoreText.setText('分數: ' + this.scene.score);

            const explosion = this.scene.add
                .sprite(this.x, this.y, 'explosion')
                .play('explode');
            explosion.on('animationcomplete', () => explosion.destroy());

            this.setActive(false).setVisible(false);
            this.body.enable = false;
            this.hpBar.clear();
        }
    }

    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) {
            this.updateHpBar();
            if (this.y > this.scene.game.config.height + 50) {
                this.setActive(false).setVisible(false);
                this.destroy();
            }
        }
    }

    preDestroy() {
        if (this.hpBar) {
            this.hpBar.destroy();
            this.hpBar = null;
        }
    }
}

class ShooterScene extends Phaser.Scene {
    constructor() {
        super('ShooterScene');
        this.player = null;
        this.enemies = null;
        this.bullets = null;
        this.starfield = null;
        this.keys = null;
        this.score = 0;
        this.scoreText = null;
        this.gameOver = false;
        this.fireRate = 200;
        this.nextFire = 0;
        this.fpsText = null;
        this.objectCountText = null;
        this.enemySpawner = null;
    }

    preload() {
        this.load.image('starfield', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/skies/starfield.png');
        this.load.image('player', 'assets/spaceship.png');
        this.load.image('enemy', 'assets/alien.png');
        this.load.image('bullet', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/bullet.png');
        this.load.spritesheet('explosion', 'https://raw.githubusercontent.com/photonstorm/phaser3-examples/master/public/assets/sprites/explosion.png', { frameWidth: 64, frameHeight: 64 });
    }

    create() {
        this.score = 0;
        this.gameOver = false;
        this.nextFire = 0;

        this.starfield = this.add.tileSprite(400, 300, 800, 600, 'starfield');

        this.player = this.physics.add.sprite(400, 500, 'player');
        this.player.setCollideWorldBounds(true);
        this.player.body.allowGravity = false;
        this.player.setScale(0.3);

        this.anims.create({
            key: 'explode',
            frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: 15 }),
            frameRate: 24,
            repeat: 0,
            hideOnComplete: true
        });

        this.enemies = this.physics.add.group({
            classType: Enemy,
            runChildUpdate: true
        });

        this.bullets = this.physics.add.group({
            removeCallback: (bullet) => {
                this.updateEntityCount();
            }
        });

        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.playerHitEnemy, null, this);

        this.scoreText = this.add.text(16, 16, '分數: 0', { fontSize: '32px', fill: '#fff' });
        this.fpsText = this.add.text(16, 50, 'FPS: 60', { fontSize: '20px', fill: '#fff' });
        this.objectCountText = this.add.text(16, 75, '物件數: 0', { fontSize: '20px', fill: '#fff' });

        this.keys = this.input.keyboard.addKeys('W,S,A,D,LEFT,RIGHT,UP,DOWN,SPACE');

        this.enemySpawner = this.time.addEvent({
            delay: 1200,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true
        });
        
        this.updateEntityCount();
    }

    update(time, delta) {
        this.fpsText.setText('FPS: ' + Math.floor(this.game.loop.actualFps));

        if (this.gameOver) return;

        this.starfield.tilePositionY -= 2;

        this.player.setVelocity(0);
        if (this.keys.A.isDown || this.keys.LEFT.isDown) {
            this.player.setVelocityX(-300);
        } else if (this.keys.D.isDown || this.keys.RIGHT.isDown) {
            this.player.setVelocityX(300);
        }

        if (this.keys.W.isDown || this.keys.UP.isDown) {
            this.player.setVelocityY(-300);
        } else if (this.keys.S.isDown || this.keys.DOWN.isDown) {
            this.player.setVelocityY(300);
        }

        if (this.keys.SPACE.isDown && time > this.nextFire) {
            this.shootBullet(time);
        }
    }

    updateEntityCount() {
        const count = 1 + this.bullets.countActive(true) + this.enemies.countActive(true);
        this.objectCountText.setText('物件數: ' + count);
    }

    spawnEnemy() {
        const x = Phaser.Math.Between(50, 750);
        const enemy = this.enemies.get();
        if (enemy) {
            enemy.spawn(x, -50);
            this.updateEntityCount();
        }
    }

    shootBullet(time) {
        const bullet = this.bullets.create(this.player.x, this.player.y - 30, 'bullet');
        if (bullet) {
            bullet.setVelocityY(-500);
            bullet.body.allowGravity = false;
            this.nextFire = time + this.fireRate;
            this.updateEntityCount();

            this.time.delayedCall(2000, () => {
                if (bullet.active) {
                    bullet.destroy();
                }
            });
        }
    }

    bulletHitEnemy(bullet, enemy) {
        if (bullet && bullet.active && enemy && enemy.active) {
            bullet.destroy();
            enemy.takeDamage(1);
            this.updateEntityCount();
        }
    }

    playerHitEnemy(player, enemy) {
        if (this.gameOver) return;

        if(this.enemySpawner) this.enemySpawner.destroy();
        
        this.gameOver = true;
        this.physics.pause();

        this.add.sprite(player.x, player.y, 'explosion').play('explode');
        this.add.sprite(enemy.x, enemy.y, 'explosion').play('explode');

        player.setVisible(false);
        enemy.destroy();

        this.add.text(400, 300, '遊戲結束\n點擊畫面重新開始', {
            fontSize: '48px',
            fill: '#ff0000',
            align: 'center',
            backgroundColor: 'rgba(0,0,0,0.7)',
            padding: { x: 20, y: 20 }
        }).setOrigin(0.5);

        this.input.once('pointerdown', () => {
            this.scene.restart();
        });
    }
}

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    scene: ShooterScene
};

const game = new Phaser.Game(config);
</script>

</body>
</html>